using CodeGen.Builders;
using CodeGen.Signature;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text.Json;

namespace CodeGen.Generators;

public sealed class TypeGenerator
{
	private readonly CodeGenTask task;

	public TypeGenerator(CodeGenTask task)
	{
		this.task = task;
	}
	public void PreInitialize(BasicTypeSignature sign)
	{
		sign.Name = ConstCaseToPascalCase(sign.Name);

		if (sign is EnumSignature enumSign)
		{
			Dictionary<string, string> _remap = new(enumSign.Entries.Count);

			foreach (var entry in enumSign.Entries)
			{
				_remap.Add(entry.FieldName, ConstCaseToPascalCase(entry.FieldName));
			}
			IImmutableDictionary<string, string> remap = _remap.OrderBy(r => r.Key, new StringLenComparer()).ToImmutableDictionary();
			foreach (var entry in enumSign.Entries)
			{
                string key = entry.FieldName;
				entry.FieldName = remap[key];

				foreach ((string from, string to) in remap)
				{
                    entry.Value = entry.Value.Replace(from, to);
				}
			}
		}
	}
	public void Generate(BasicTypeSignature sign)
	{
		using CodeWriter cw = new();

		string fileName = task?.Output?.TargetDirectory is null ? sign.Name + ".gen.cs" : Path.Combine(task.Output.TargetDirectory, sign.Name + ".gen.cs");
		bool partial = File.Exists(Path.Combine(Path.GetDirectoryName(fileName) ?? string.Empty, sign.Name + ".cs"));

		cw.Write($"""
			/*  This file is automatic generated by NiTiS-Dev/NiTiS.Native:CodeGen
			 *  Generation time: {DateTime.UtcNow}
			 */
			""");

		cw.WriteLine();
		cw.WriteLine("#pragma warning disable 1591");
		cw.WriteLine();

		if (!string.IsNullOrWhiteSpace(sign.Namespace))
			cw.WriteLine($"namespace {sign.Namespace};");

		cw.WriteLine();
		cw.PushCompilerGenerated();
		cw.WriteLine($"public {(partial ? "partial " : string.Empty)}{sign.TypeKeyword} {sign.Name}");
		cw.BeginBlock();
		{
			if (sign is EnumSignature enumSign)
				GenerateEnum(enumSign, cw);
		}
		cw.EndBlock();

		cw.WriteLine();
		cw.WriteLine("#pragma warning restore");
		cw.WriteLine();

		File.WriteAllText(fileName, cw.ToString());
	}
	private void GenerateEnum(EnumSignature sign, CodeWriter cw)
	{
		foreach (EnumValueSignature val in sign.Entries)
		{
			cw.WriteLine($"{val.FieldName} =  unchecked((int){val.Value})");
			cw.Write(',');
		}
	}

	private string ConstCaseToPascalCase(string origin)
	{
		if (origin.Any(static c => char.IsLower(c)))
			return origin;

		Span<char> buffer = stackalloc char[origin.Length];

		int index = origin.StartsWith("GLFW_") ? 5 : 0;

		bool isNewWord = true;
		int bufferIndex = 0;
		for (;index < origin.Length; index++)
		{
			char c = origin[index];

			if (c is '_')
			{
				isNewWord = true;
			}
			else
			{
				buffer[bufferIndex++] = isNewWord ? char.ToUpper(c) : char.ToLower(c);

				isNewWord = false;
			}
		}

		return new(buffer.Slice(0, bufferIndex));
	}

	private class StringLenComparer : IComparer<string>
	{
		public int Compare(string x, string y)
		{
			int lengthComparison = x.Length.CompareTo(y.Length);

			if (lengthComparison == 0)
			{
				return x.CompareTo(y);
			}
			else
			{
				return lengthComparison;
			}
		}
	}
}
