using CodeGen.Builders;
using CodeGen.Signature;
using NiTiS.Collections;
using NiTiS.Core;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using NiTiS.Core.Extensions;

namespace CodeGen.Generators;

public sealed class TypeGenerator
{
	private readonly CodeGenTask task;

	public TypeGenerator(CodeGenTask task)
	{
		this.task = task;
	}
	public void PreInitialize(BasicTypeSignature sign)
	{
		if (sign.Name.Contains(':'))
		{
			int index = sign.Name.IndexOf(':');

			string @namespace = sign.Name.Remove(index);
			string name = sign.Name.Substring(index + 1);

			sign.Namespace = @namespace;
			sign.Name = name;
		}
		else
			sign.Name = ConstCaseToPascalCase(sign.Name);

		if (sign is EnumSignature enumSign)
		{

			string?
				postfix = null,
				prefix = null
				;
			{
				CodeGenRange? range = task?.Map?.Ranges?.Where(rng => rng.Name == enumSign.Name)?.FirstOrDefault();
				prefix = range?.Prefix;
				postfix = range?.Postfix;
			}

            for (int enumValueId = 0; enumValueId < enumSign.Entries.Count; enumValueId++)
			{
				EnumValueSignature valSign = enumSign.Entries[enumValueId];

				valSign.FieldName = ConstCaseToPascalCase(valSign.FieldName); // Normalize enum value name

				if (valSign.FieldName.HasPrefix(prefix)) // Remove prefix
				{
					valSign.FieldName = valSign.FieldName[prefix!.Length..];
				}
				if (valSign.FieldName.HasPostfix(postfix)) // Remove postfix
				{
                    valSign.FieldName = valSign.FieldName[..^postfix!.Length];
				}
			}

			List<EnumValueSignature> originOrder = new(enumSign.Entries);

			enumSign.Entries.Sort((cmp, cmp2) => cmp2.FieldName.Length - cmp.FieldName.Length);

			foreach (EnumValueSignature valSign in enumSign.Entries)
			{
                if (task?.Map?.Rename?.TryGetValue(valSign.FieldName, out string? replacement) ?? false) {
                    valSign.FieldName = replacement;
				}

				foreach (EnumValueSignature valSign2 in enumSign.Entries)
				{
					if (valSign2.NativeName is null)
						continue;

					valSign.Value = valSign.Value.Replace(valSign2.NativeName, valSign2.FieldName);
				}

				valSign.Value = valSign.Value.Trim(' ', '\n', '\r');
			}

			enumSign.Entries = originOrder; // Restore right order
		}
		else if (sign is NonEnumSignature typeSign)
		{
			foreach (FunctionSignature fun in typeSign.Functions)
			{

			}
		}
	}
	public void Generate(BasicTypeSignature sign)
	{
		using CodeWriter cw = new();

		string fileName = task?.Output?.TargetDirectory is null ? sign.Name + ".gen.cs" : Path.Combine(task.Output.TargetDirectory, sign.Name + ".gen.cs");
		bool partial = File.Exists(Path.Combine(Path.GetDirectoryName(fileName) ?? string.Empty, sign.Name + ".cs"));

		cw.Write($"""
			/*  This file is automatic generated by NiTiS-Dev/NiTiS.Native:CodeGen
			 *  Generation time: {DateTime.UtcNow}
			 *  Source files: {task?.IncludeFiles?.EnumerableToString()}
			 */
			""");

		cw.WriteLine();
		cw.WriteLine("#pragma warning disable 1591");
		cw.WriteLine();

		if (!string.IsNullOrWhiteSpace(sign.Namespace))
			cw.WriteLine($"namespace {sign.Namespace};");

		cw.WriteLine();
		cw.PushCompilerGenerated();
		cw.WriteLine($"public {(partial ? "partial " : string.Empty)}{sign.TypeKeyword} {sign.Name}");
		cw.BeginBlock();
		{
			if (sign is EnumSignature enumSign)
				GenerateEnum(enumSign, cw);
			else if (sign is NonEnumSignature typeSign)
				GenerateType(typeSign, cw);
		}
		cw.EndBlock();

		cw.WriteLine();
		cw.WriteLine("#pragma warning restore");
		cw.WriteLine();

		File.WriteAllText(fileName, cw.ToString());
	}
	private void GenerateEnum(EnumSignature sign, CodeWriter cw)
	{
		foreach (EnumValueSignature val in sign.Entries)
		{
			cw.WriteLine($"{val.FieldName} =  unchecked((int){val.Value}),");
		}
	}
	private void GenerateType(NonEnumSignature sign, CodeWriter cw)
	{
		foreach (FunctionSignature fun in sign.Functions)
		{

			cw.PushHide();
			cw.PushCompilerGenerated();
			cw.WriteIndent();
			cw.Write("public ");
			cw.Write(sign.IsStatic ? "static " : string.Empty);
			cw.Write("unsafe delegate* ");
			if (!fun.Convention.IsImplicit)
			{
				cw.Write($"unmanaged[{fun.Convention.Name}] ");
			}

			cw.Write('<');
			foreach (ArgumentSignature arg in fun.Arguments)
			{
				cw.Write($"{arg.Type.Name} /* {arg.NativeName} */, ");
			}
			cw.Write(fun.ReturnType.Name);
			cw.Write('>');

			cw.Write(" @__");
			cw.Write(fun.Name);
			cw.Write(";");

			cw.WriteLine();
			cw.WriteLine();
		}
	}

	private string ConstCaseToPascalCase(string origin)
	{
		if (origin.Any(static c => char.IsLower(c)))
			return origin;

		Span<char> buffer = stackalloc char[origin.Length];

		int index = origin.StartsWith("GLFW_") ? 5 : 0;

		bool isNewWord = true;
		int bufferIndex = 0;
		for (;index < origin.Length; index++)
		{
			char c = origin[index];

			if (c is '_')
			{
				isNewWord = true;
			}
			else
			{
				buffer[bufferIndex++] = isNewWord ? char.ToUpper(c) : char.ToLower(c);

				isNewWord = false;
			}
		}

		return new(buffer.Slice(0, bufferIndex));
	}
}
